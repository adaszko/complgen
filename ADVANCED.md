### Generate completions on stdout by compiling the grammar "just-in-time":


This mode is useful if you're command line user and want to improve the CLI experience on *your* machine by
either implementing a missing autocompletion for a specific CLI tool, or override the default one with a one
better tailored for your needs and usage patterns.  Or you simply want to iterate quickly on a `.usage` file
before you compile it to a shell script.

The just-in-time mode is intended to be further integrated with shells so that it provides completions
directly from grammars, bypassing compilation and `source`ing completion shell script files.

Note that it is assummed the `.usage` file stem is the same as the completed command name, so to complete
`grep` command, its grammar needs to land in `grep.usage`.

### Bash Integration

Note: This assumes you have `bash-completion` OS-level package installed and it's been sourced!  It often
boils down to `apt install bash-completion; source /etc/bash_completion` or `brew install bash-completion;
source /opt/homebrew/etc/profile.d/bash_completion.sh`, depending on your OS.  Without this package, scripts
generated by `complgen` are not able to correctly process command lines containing characters like `=`, `:`,
`@`, or any other from `$COMP_WORDBREAKS`.

See also https://github.com/git/git/commit/da48616f1df51ff43acc64cdf8966f7b72142a11

Assumming your `.usage` files are stored in the `~/.config/complgen` directory, add this to your `~/.bashrc`:

<details>

```bash
for path in ~/.config/complgen/*.usage; do
    stem=$(basename "$path" .usage)
    eval "
_complgen_jit_$stem () {
    local words cword
    _get_comp_words_by_ref -n \"\$COMP_WORDBREAKS\" words cword
    local prefix="\${words[\$cword]}"
    local bash_code=\"\$(complgen jit \"{usage_files_dir}/${stem}.usage\" bash --comp-wordbreaks=\"\$COMP_WORDBREAKS\" --prefix=\"\$prefix\" -- \"\${words[@]:1:\$cword-1}\")\"
    eval \"\$bash_code\"
    return 0
}
"
    complete -o nospace -F _complgen_jit_$stem "$stem"
    unset stem
done
```
</details>

### Fish Integration

Assumming your `.usage` files are stored in the `~/.config/complgen` directory, add this to your `~/.config/fish/config.fish`:

<details>

```fish
function _complgen_jit
    set --local COMP_LINE (commandline --cut-at-cursor)
    set --local COMP_WORDS
    echo $COMP_LINE | read --tokenize --array COMP_WORDS
    if string match --quiet --regex '.*\s$' $COMP_LINE
        set COMP_CWORD (math (count $COMP_WORDS) + 1)
    else
        set COMP_CWORD (count $COMP_WORDS)
    end
    set --local usage_file_path $argv[1]
    set --local prefix $COMP_WORDS[$COMP_CWORD]
    set --local last (math $COMP_CWORD - 1)
    if test $last -lt 2
        set words
    else
        set words $COMP_WORDS[2..$last]
    end
    complgen jit $usage_file_path fish --prefix="$prefix" -- $words | source -
    __complgen_jit "$prefix"
end

for path in ~/.config/complgen/*.usage
    set --local stem (basename $path .usage)
    complete --erase $stem
    complete --command $stem --no-files --arguments "(_complgen_jit ~/.config/complgen/$basename.usage)"
end
```
</details>

### Zsh Integration

Assumming your `.usage` files are stored in the `~/.config/complgen` directory, add this to your `~/.zshrc`:

<details>

```zsh
_complgen_jit () {
    local stem=$1
    local -a w=("${(@)words[2,$CURRENT-1]}")
    local zsh_code=$(complgen jit ~/.config/complgen/${stem}.usage zsh --prefix="$PREFIX" -- "${w[@]}")
    eval $zsh_code
    return 0
}

for f in $HOME/.config/complgen/*.usage(N); do
    local stem=$f:t:r
    compdef "_complgen_jit $stem" $stem
done
```

</details>


